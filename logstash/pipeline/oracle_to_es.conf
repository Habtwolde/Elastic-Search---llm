input {
  jdbc {
    jdbc_driver_library => "/usr/share/logstash/drivers/ojdbc8.jar"
    jdbc_driver_class => "Java::oracle.jdbc.OracleDriver"

    # Build JDBC connection string from env vars injected by docker-compose
    jdbc_connection_string => "jdbc:oracle:thin:@//${ORACLE_HOST}:${ORACLE_PORT}/${ORACLE_SERVICE}"
    jdbc_user => "${ORACLE_USER}"
    jdbc_password => "${ORACLE_PASSWORD}"

    # Polling schedule (every 1 minute)
    schedule => "* * * * *"

    # SQL: incremental loads based on updated_at (exclude NULLs to avoid missing rows)
    statement => "
      SELECT
        id,
        title,
        body,
        updated_at
      FROM docs
      WHERE updated_at IS NOT NULL
        AND updated_at > :sql_last_value
      ORDER BY updated_at ASC
    "

    # Track incremental loads based on updated_at
    use_column_value => true
    tracking_column => "updated_at"
    tracking_column_type => "timestamp"

    # Persist last-run state inside the container
    last_run_metadata_path => "/usr/share/logstash/data/.logstash_jdbc_last_run"

    # First run behavior
    clean_run => false

    # Paging for larger tables (safe defaults)
    jdbc_paging_enabled => true
    jdbc_page_size => 500

    # Ensure timestamps are handled consistently
    jdbc_default_timezone => "UTC"

    # Optional: keep connection stable under intermittent networks
    jdbc_validate_connection => true
    jdbc_validation_timeout => 60
  }
}

filter {
  # Defensive normalization for title/body
  if [body] {
    # If body is an array, join it
    if [body] and [body][0] {
      mutate { join => { "body" => "\n" } }
    }
  } else {
    mutate { add_field => { "body" => "" } }
  }

  if [title] {
    mutate { strip => ["title"] }
  } else {
    mutate { add_field => { "title" => "" } }
  }

  # Ensure id is consistent (string) for ES _id usage
  mutate {
    convert => { "id" => "string" }
  }

  # Create the field that the ingest pipeline expects (real newline, not "\n")
  ruby {
    code => '
      t = event.get("title") || ""
      b = event.get("body")  || ""
      if b.is_a?(Array)
        b = b.join("\n")
      end
      event.set("content", "#{t}\n#{b}")
    '
  }
}

output {
  elasticsearch {
    hosts    => ["http://elasticsearch:9200"]
    user     => "${ELASTIC_USER}"
    password => "${ELASTIC_PASSWORD}"

    index       => "oracle_elser_index_v2"
    document_id => "%{id}"
    pipeline    => "elser_oracle_pipeline"
  }

  stdout { codec => rubydebug }
}

